
半同步/半反应堆线程池
===============
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * 半同步/半反应堆
> * 线程池
## Web服务器与线程池的关系

Web服务器需要**同时处理多个客户端请求**，并且每个请求可能需要花费很长时间来处理，如数据库查询、文件读写等操作。

因此**Web服务器不太可能是单线程的**，要实现并发操作就必须引入多线程技术

使用线程池的服务器属于多线程服务器。**线程池本质上是一种多线程技术**，通过在程序启动时创建一定数量的工作线程，并将所有请求任务加入到任务队列中，以便线程池中的多个工作线程可以同时处理请求任务。

在Web服务器中，线程池的作用是**有效地处理并发请求，提高服务器的并发能力和性能**。



具体地，Web服务器通过线程池实现以下几个方面的功能：

1. **提高并发性能**：线程池可以在同一时刻处理多个请求，从而提高服务器的并发处理能力，减少请求响应时间。
2. **控制线程数量**：线程池可以控制同时执行的线程数量，从而避免线程数目过多导致系统资源耗尽。
3. **管理线程状态**：线程池可以对工作线程进行管理，并监测工作线程的状态，如是否空闲、是否存活等。
4. **避免线程创建销毁开销**：使用线程池可以避免频繁地创建和销毁线程，从而减少系统开销，提高服务器的性能。

![image](https://github.com/DAYceng/NoobWebServerV1.5/assets/39471587/aa52b688-6806-44d5-8acc-7835fb62a7ae)

## 实现一个线程池

> 前置知识：互斥锁、信号量、C++模板编程
>
> （注：代码中使用的）

线程池在代码实现上是一个模板类，使用模板的原因是方便进行复用

线程池模板类，**主要用于管理多个线程并处理任务**。其中包含以下主要成员变量和函数：

- **成员变量**：线程数量（m_thread_number）、最大请求数（m_max_requests）、线程池数组（m_threads）、请求队列（m_workqueue）、互斥锁（m_queuelocker）、信号量（m_queuestat）和是否停止标志（m_stop）。
- **成员函数**：构造函数（threadpool()）、析构函数（~threadpool()）、添加任务（append()）、子线程中要执行的工作函数（worker()）和启动线程池中的一个或多个线程进行任务处理的函数（run()）。

下面是该代码的工作流程和原理：

​	1、**创建线程池**

创建时，会先判断线程数和最大请求数是否小于等于0。之后，会创建一个大小为 m_thread_number 的线程池数组，并将其设置为线程脱离状态，即在创建完线程之后就可以将其与当前的进程分离，避免线程阻塞主线程和其他相关线程的运行。如果创建时失败，则抛出异常。

​	2、**添加任务**

往任务队列中添加请求时，会先加锁（使用互斥锁），以确保多个进程不会争抢。之后，会判断任务队列中的请求数是否超过 m_max_requests，如果队列大小大于最大请求数，则解锁并返回 false。否则，将请求添加到队列中，解锁并增加信号量，通知线程池中的线程，有新任务需要处理。最终返回 true。

​	3、**线程工作函数**

当收到信号量后，线程会先上锁（使用互斥锁），以确保多个线程不会同时访问队列。之后，会判断任务队列是否为空。如果队列为空，则解锁并继续等待下一次信号量的到来。否则，取出队列顶部的请求，并将其弹出队列。最后，解锁，并调用任务函数（request->process()）。

​	4、**析构函数**

执行析构函数时，将 m_stop 设置为 true，供线程判断是否要停止。








